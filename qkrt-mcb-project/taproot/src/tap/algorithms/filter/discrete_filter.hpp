/*****************************************************************************/
/********** !!! WARNING: CODE GENERATED BY TAPROOT. DO NOT EDIT !!! **********/
/*****************************************************************************/

/*****************************************************************************/
/********** !!! WARNING: CODE GENERATED BY TAPROOT. DO NOT EDIT !!! **********/
/*****************************************************************************/

/*
 * Copyright (c) 2024-2025 Advanced Robotics at the University of Washington <robomstr@uw.edu>
 *
 * This file is part of Taproot.
 *
 * Taproot is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Taproot is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Taproot.  If not, see <https://www.gnu.org/licenses/>.
 */

/**
 * @file discrete_filter.hpp
 * @brief Contains the implementation of discrete-time filters and filter cascades.
 *
 * - `CascadeFilter`: A variadic template class for composing multiple filters in series (cascade).
 *   It supports runtime and compile-time access to individual filters, as well as operator*
 *   overloads for convenient cascade construction.
 *   Usage: CascadeFilter<DiscreteFilter<n>,DiscreteFilter<n>> cascade = filter1 * filter2;
 * - `Coefficients`: A structure representing the coefficients for discrete filters.
 * - `DiscreteFilter`: A template class implementing a generic discrete-time filter using the
 *   finite difference equation.
 *
 * @author Aiden Prevey
 * @date 8/30/2025
 */

#ifndef TAPROOT_DISCRETE_FILTER_HPP_
#define TAPROOT_DISCRETE_FILTER_HPP_

#include <array>
#include <cstdint>

#include "modm/architecture/interface/assert.hpp"

namespace tap::algorithms::filter
{
template <typename... Filters>
class CascadeFilter;

/**
 * @brief CascadeFilter base object, holds n filters in series
 * Each filter's output is the next filter's input
 *
 * @code auto cascade = filter * filter;
 *
 * @tparam Filter
 */
template <typename Filter>
class CascadeFilter<Filter>
{
public:
    explicit CascadeFilter(const Filter& f) : f_(f) {}

    std::size_t size() const noexcept { return 1; }

    // runtime index access
    Filter& operator[](std::size_t i)
    {
        modm_assert(i == 0, "Cascade Index", "Index out of range for CascadeFilter<Filter>");
        return f_;
    }
    const Filter& operator[](std::size_t i) const
    {
        modm_assert(i == 0, "Cascade Index", "Index out of range for CascadeFilter<Filter>");
        return f_;
    }

    // compile-time getter for pack-expansion use in operator*
    template <std::size_t I>
    auto& get()
    {
        modm_assert(I == 0, "Cascade Index", "Index out of range for CascadeFilter<Filter>");
        return f_;
    }
    template <std::size_t I>
    const auto& get() const
    {
        modm_assert(I == 0, "Cascade Index", "Index out of range for CascadeFilter<Filter>");
        return f_;
    }

    template <typename Float = float>
    auto filterData(Float x)
    {
        return f_.filterData(x);
    }

    auto getLastFiltered() const { return f_.getLastFiltered(); }

    void reset() { f_.reset(); }

private:
    Filter f_;
};

/** Recursive filter, holds n filters in series
   Each filter's output is the next filter's input

   @code auto cascade = filter * filter * filter;

   @tparam First First filter in the cascade
   @tparam Rest  Remaining filters in the cascade
 */
template <typename First, typename... Rest>
class CascadeFilter<First, Rest...>
{
public:
    // Constructor that allows for a variadic number of filters
    CascadeFilter(const First& f, const Rest&... rest) : first_(f), rest_(rest...) {}

    size_t size() const noexcept { return 1 + rest_.size(); }

    auto& operator[](std::size_t i)
    {
        if (i == 0) return first_;
        return rest_[i - 1];
    }
    const auto& operator[](std::size_t i) const
    {
        if (i == 0) return first_;
        return rest_[i - 1];
    }

    // compile-time getter for pack-expansion use in operator*
    template <std::size_t I>
    auto& get()
    {
        if constexpr (I == 0)
        {
            return first_;
        }
        else
        {
            return rest_.template get<I - 1>();
        }
    }
    template <std::size_t I>
    const auto& get() const
    {
        if constexpr (I == 0)
        {
            return first_;
        }
        else
        {
            return rest_.template get<I - 1>();
        }
    }

    template <typename Float = float>
    auto filterData(Float x)
    {
        auto tmp = first_.filterData(x);
        return rest_.filterData(tmp);
    }

    auto getLastFiltered() const { return rest_.getLastFiltered(); }

    void reset()
    {
        first_.reset();
        rest_.reset();
    }

private:
    First first_;
    CascadeFilter<Rest...> rest_;
};

// Deduction guide for CascadeFilter
template <typename... Fs>
CascadeFilter(Fs...) -> CascadeFilter<Fs...>;

// Helper to concatenate two CascadeFilters
template <typename... As, typename... Bs, std::size_t... I, std::size_t... J>
auto concat_impl(
    const CascadeFilter<As...>& a,
    const CascadeFilter<Bs...>& b,
    std::index_sequence<I...>,
    std::index_sequence<J...>)
{
    /* Expands into CascadeFilter<As..., Bs...>(a.get<0>(), a.get<1>(), ..., b.get<0>(), b.get<1>(),
       ...) where .get is the filter at that index */
    return CascadeFilter<As..., Bs...>(a.template get<I>()..., b.template get<J>()...);
}

/** @brief `CascadeFilter` * `CascadeFilter`
 * Creates a new CascadeFilter, see concat_impl for details
 * @tparam As Filters in the existing CascadeFilter
 * @tparam B Filter to add to the end of the CascadeFilter
 */
template <typename... As, typename... Bs>
auto operator*(const CascadeFilter<As...>& a, const CascadeFilter<Bs...>& b)
{
    return concat_impl(a, b, std::index_sequence_for<As...>{}, std::index_sequence_for<Bs...>{});
}

/** @brief `Filter` * `CascadeFilter`
 * Creates a new CascadeFilter with a variadic
 * template expansion, adding n filters to the rhs of cascade
 * Is the inverse case of CascadeFilter * Filter
 * @tparam As Filters in the existing CascadeFilter
 * @tparam B Filter to add to the end of the CascadeFilter
 */
template <typename A, typename... Bs>
auto operator*(const A& a, const CascadeFilter<Bs...>& b)
{
    return [&]<std::size_t... J>(std::index_sequence<J...>)
    {
        return CascadeFilter<A, Bs...>(a, b.template get<J>()...);
    }
    (std::index_sequence_for<Bs...>{});
}

/** @brief `CascadeFilter` * `Filter`
 * Creates a new CascadeFilter with a variadic
 * template expansion, adding n filters to the rhs of cascade
 * @tparam As Filters in the existing CascadeFilter
 * @tparam B Filter to add to the end of the CascadeFilter
 */
template <typename... As, typename B>
auto operator*(const CascadeFilter<As...>& a, const B& b)
{
    /* Create a lambda to expand the indices of get<>() for each
       filter that exists in the CascadeFilter */
    return [&]<std::size_t... I>(std::index_sequence<I...>)
    {
        /* Expands into CascadeFilter<As..., B>(a.get<0>(), a.get<1>(), ..., b)
           for each existing filter in the CascadeFilter */
        return CascadeFilter<As..., B>(a.template get<I>()..., b);
    }
    (std::index_sequence_for<As...>{});
    // call the lambda with an index sequence for the existing filters
}

/** @brief `DiscreteFilter` * `DiscreteFilter`
 * Creates a normal CascadeFilter
 */
template <typename A, typename B>
auto operator*(const A& lhs, const B& rhs)
{
    return CascadeFilter<A, B>(lhs, rhs);
}

/**
 * @struct Coefficients
 * @brief Represents the coefficients used in a discrete filter.
 *
 * This structure holds two sets of coefficients:
 * - `naturalResponseCoefficients`: Coefficients related to the natural response of the system.
 * - `forcedResponseCoefficients`: Coefficients related to the forced response of the system.
 *
 * @tparam T The data type of the coefficients (e.g., float, double).
 * @tparam SIZE The size of the coefficient arrays.
 */
template <uint8_t SIZE, typename T = float>
struct Coefficients
{
    std::array<T, SIZE> naturalResponseCoefficients;
    std::array<T, SIZE> forcedResponseCoefficients;
};

/**
 * @brief DiscreteFilter class implements a discrete-time filter using the finite difference
 * equation.
 * @tparam SIZE The size of the filter coefficients.
 *
 * This class provides methods to filter input data using the finite difference equation and
 * maintain the internal state of the filter.
 */
template <uint8_t SIZE, typename T = float>
class DiscreteFilter
{
public:
    /**
     * @brief Constructor for the DiscreteFilter class.
     * @param [in] naturalResponseCoefficients The coefficients for the natural response (a).
     * @param [in] forcedResponseCoefficients The coefficients for the forced response (b).
     *
     * This constructor initializes the filter with the given coefficients and resets the filter
     * state to zero.
     */
    DiscreteFilter(
        std::array<T, SIZE> naturalResponseCoefficients,
        std::array<T, SIZE> forcedResponseCoefficients)
        : naturalResponseCoefficients(naturalResponseCoefficients),
          forcedResponseCoefficients(forcedResponseCoefficients)
    {
        reset();
    }

    DiscreteFilter(const Coefficients<SIZE, T> coefficients)
        : naturalResponseCoefficients(coefficients.naturalResponseCoefficients),
          forcedResponseCoefficients(coefficients.forcedResponseCoefficients)
    {
        reset();
    }

    /**
     * @brief Filters the input data using the finite difference equation.
     * @param [in] dat The input data to be filtered.
     * @return The filtered output data.
     *
     * This function implements a discrete-time filter using the finite difference equation.
     * It updates the internal state of the filter based on the input data and returns the
     * filtered output.
     *
     * \f$ y(n)=\frac{1}{a_{0}}\left[\sum_{\kappa=0}^{M} b_{\kappa}x(n-\kappa)-\sum_{k=1}^{N}
     * a_{k}y(n-k)\right]. \qquad{(2)} \f$
     *
     */
    T filterData(float dat)
    {
        for (int i = SIZE - 1; i > 0; i--)
        {
            forcedResponse[i] = forcedResponse[i - 1];
        }
        forcedResponse[0] = dat;

        float sum = 0;
        // Sum of forced response coefficients multiplied by the forced response X(n-k)
        // (previous input data)
        for (int i = 0; i < SIZE; i++)
        {
            sum += forcedResponseCoefficients[i] * forcedResponse[i];
        }
        // Sum of natural response coefficients multiplied by the natural response Y(n-k)
        // (previous output data)
        for (int i = 0; i < SIZE - 1; i++)
        {
            sum -= naturalResponseCoefficients[i + 1] * naturalResponse[i];
        }
        // Apply the 1/a_0 scaling to the output
        sum /= naturalResponseCoefficients[0];

        // Shift the natural response array to make room for the new output
        for (int i = SIZE - 1; i > 0; i--)
        {
            naturalResponse[i] = naturalResponse[i - 1];
        }

        naturalResponse[0] = sum;

        return naturalResponse[0];
    }

    /** @brief Returns the last filtered value*/
    T getLastFiltered() { return naturalResponse[0]; }
    T getLastFiltered() const { return naturalResponse[0]; }

    /** @brief Resets the filter's state to zero, keeps the coefficients  */
    T reset()
    {
        // Reset the filter state to zero
        naturalResponse.fill(0.0f);
        forcedResponse.fill(0.0f);
        return 0.0f;
    }

    /** @brief Allows for setting a steady state value, good if starting at a non-zero value */
    T setSteadyState(T steadyState)
    {
        naturalResponse.fill(steadyState);
        forcedResponse.fill(steadyState);
        return steadyState;
    }

    void setCoefficients(Coefficients<SIZE, T> coe)
    {
        this->naturalResponseCoefficients = coe.naturalResponseCoefficients;
        this->forcedResponseCoefficients = coe.forcedResponseCoefficients;
    }

    void setCoefficients(
        std::array<T, SIZE> naturalResponseCoefficients,
        std::array<T, SIZE> forcedResponseCoefficients)
    {
        this->naturalResponseCoefficients = naturalResponseCoefficients;
        this->forcedResponseCoefficients = forcedResponseCoefficients;
    }

private:
    std::array<T, SIZE> naturalResponseCoefficients;
    std::array<T, SIZE> forcedResponseCoefficients;
    std::array<T, SIZE> naturalResponse;
    std::array<T, SIZE> forcedResponse;
};

}  // namespace tap::algorithms::filter

#endif  // TAPROOT_DISCRETE_FILTER_HPP_